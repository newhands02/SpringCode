### Java类加载器

##### 1.类加载器：将class文件加载到虚拟机中，一共定义了4种类型的加载器，分别是：

BoostrapClassLoader:启动类加载器，Java顶层加载器，主要加载%JRE_HOME%\lib下的jar包，可以通过 -Xbootclasspath指定被虚拟机加载的目录

![image-20210717150335390](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210717150335390.png)

ExtensionClassLoader：拓展类加载器，加载%JAVA_HOME%\lib\ext下的资源，通过系统变量：java.ext.dirs进行指定

![image-20210717150442437](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210717150442437.png)

ApplicaitonClassLoader：应用程序加载器，负责加载classpath路径下的资源

![image-20210717150511579](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210717150511579.png)

UserClassLoader：用户自定义加载器，通过继承ClassLoader类来实现自定义加载资源

```java
/**Launcher是java虚拟机的入口应用
**/
//boostrap加载器没有在这个过程中生成
private static String bootClassPath = System.getProperty("sun.boot.class.path");
public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            //获取到了extension加载器
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError("Could not create extension class loader", var10);
        }

        try {
            //获取到了application加载器
            //var1就是extClassLoader，就是父类加载器，作为参数传入是为了设置它的父类加载器
            /**private ClassLoader(Void unused, ClassLoader parent) {
        	          this.parent = parent;
        	 跟踪到最后在ClassLoader里将this.parent设为var1，这样掉用class.getClassLoader.getParent**/
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }

        Thread.currentThread().setContextClassLoader(this.loader);
    	//这里生成Security manager猜测是用作双亲委派的安全检查（猜测错误，是用来检查是否有权限创建加载器）
    	
    	//源码中是这样写的
        //The security manager is a class that allows applications to implement a security policy. It allows an application to determine, before performing a possibly unsafe or sensitive operation, what the operation is and whether it is being attempted in a security context that allows the operation to be performed. The application can allow or disallow the operation.
        String var2 = System.getProperty("java.security.manager");
        if (var2 != null) {
            SecurityManager var3 = null;
            if (!"".equals(var2) && !"default".equals(var2)) {
                try {
                    var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
                } catch (IllegalAccessException var5) {
                } catch (InstantiationException var6) {
                } catch (ClassNotFoundException var7) {
                } catch (ClassCastException var8) {
                }
            } else {
                var3 = new SecurityManager();
            }

            if (var3 == null) {
                throw new InternalError("Could not create SecurityManager: " + var2);
            }

            System.setSecurityManager(var3);
        }
```

注意：applicaitonClassLoader的getParent（）是ExtClassLoader，但是ExtClassLoader的getParent却为null

原因：BootstrapClassLoader由C++编写，在Java中没有实现

![image-20210717154713896](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210717154713896.png)

2.双亲委派机制

当加载器想要去加载一个类时，先到缓存中查找是否已经有这个类，如果没有，则将加载请求委托给父类加载器，然后重复此过程，直到最顶层的BootstrapClassLoader也没有找到这个类，则将委托交还给子加载器，直到用户自定义加载器也没有找到该资源，则抛出classnotfoundexception

3.类加载过程源码

```java
 protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        //因为extClassLaoader的getParent为null，所以此时需要去找Bootstrap
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //由类加载器去实现
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

来看一下URLClassLoader的findClass（appClassLoader和extClassLoader都继承了这个类）

```java
protected Class<?> findClass(final String name)
        throws ClassNotFoundException
    {
        final Class<?> result;
        try {
            result = AccessController.doPrivileged(
                new PrivilegedExceptionAction<Class<?>>() {
                    public Class<?> run() throws ClassNotFoundException {
                        String path = name.replace('.', '/').concat(".class");
                        //找这个资源，没找到就返回null，或者抛出异常
                        Resource res = ucp.getResource(path, false);
                        if (res != null) {
                            try {
                                //如果找到了资源，就去定义这个类，定义失败了就抛出异常
                                return defineClass(name, res);
                            } catch (IOException e) {
                                throw new ClassNotFoundException(name, e);
                            }
                        } else {
                            return null;
                        }
                    }
                }, acc);
        } catch (java.security.PrivilegedActionException pae) {
            throw (ClassNotFoundException) pae.getException();
        }
    	//findClass失败，也会抛出异常
        if (result == null) {
            throw new ClassNotFoundException(name);
        }
        return result;
    }
```

#### 总结

所以双亲委派机制加载class的过程可以概括为由UserClassLoader->applicaitonClassLoader->extClassLoader->BoostrapClassLoader开始一路往上去调用loadClass，有的话就返回Class<?>,一直到顶层类加载都没能load的话，就开始调用findClass，父加载器的findClass抛出的异常会被子加载器捕获，然后继续向下findClass，直到最下层的加载器都没能找到的化就抛出classnotfoundException

