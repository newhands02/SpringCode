### 对象内存布局：

​	一个对象包括对象头、data、补齐位三部分

### 对象头具体包括什么：

​	包括8位markword和4位classpointer

classPointer就是指向这个对象的指针

markword：锁的信息、hashCode、GC标记信息

![markword结构图](https://www.pianshen.com/images/614/56f038b6ed27a7f20387bf03a7b3dafe.png)

### Object o=new Obejct()在内存中占多少个字节

```java
public class AObjectSize {
    private static class T{
        int a;
        int b;
        boolean flag;
        String s="hello";
    }

    public static void main(String[] args) {
        T t=new T();
        System.out.println(ClassLayout.parseInstance(t).toPrintable());
    }
}
//========================================================================================
//打印结果
com.xyj.jvm.AObjectSize$T object internals:
OFF  SZ               TYPE DESCRIPTION               VALUE
  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4                    (object header: class)    0xf800c143
 12   4                int T.a                       0
 16   4                int T.b                       0
 20   1            boolean T.flag                    false
 21   3                    (alignment/padding gap)   
 24   4   java.lang.String T.s                       (object)
 28   4                    (object alignment gap)    
Instance size: 32 bytes
Space losses: 3 bytes internal + 4 bytes external = 7 bytes total
//========================================================================================
这里的str是一个指针，正常时64位，这里只有32位的原因是使用了-XX:+UserCompressedClassPointers命令进行指针压缩
    
```

![image-20210725170955744](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210725170955744.png)

对象怎么分配：

其中age的大小由-XX:MaxTenuringThreshold参数设置

![image-20210725173137528](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210725173137528.png)

### Class对象实例在堆还是在方法区

#### java对象模型：OOP-Klass二元对象模型

​	jvm没有将java对象直接映射为c++对象，因为c++对象需要包含一个虚表(virtual table),造成java对象过大，所以用二元对象模型来描述。

OOP：Ordinary Object Pointer:普通对象指针：表示对象的实例信息

Klass：元数据和方法信息，是java类在c++中的表示形式

![image-20210725174247048](C:\Users\661572\AppData\Roaming\Typora\typora-user-images\image-20210725174247048.png)

### 怎么定位对象：

```java
class Model
{
    public static int a = 1;
    public int b;
    public Model(int b) {
        this.b = b;
    }
}
public static void main(String[] args) {
    int c = 10;
    Model modelA = new Model(2);
    Model modelB = new Model(3);
}
/**
对象的定位访问方式实际上分为两种：句柄访问和直接指针访问，下图就是直接指针访问。直接指针访问的优点就是处理速度快，节省了一次指针定位的时间开销。句柄访问方式，需要在堆中开辟一个句柄池，栈中的reference存储的就是句柄地址，句柄包含了对象实例数据和类型数据各自的地址。句柄访问方式的优点是对象被移动时，只需要修改句柄的数据地址即可，操作简单。
**/
```

![img](https://img-blog.csdnimg.cn/20200907190155452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYmluZzE0NzE=,size_16,color_FFFFFF,t_70#pic_center)

句柄指针：不需要频繁改变指针

直接指针：速度快

### 如何创建一个对象：

​	实例化，初始化，设置引用

### DCL到底需不需要volite：

​		volite的作用时保证可见性和指令重排

```java
public Object getInstance(){
    if(INSTANCE==null){
        synchorize(Object.class){
            if(INSTANCE==null){
                this.INSTANCE=new Object(); 
                /***这里创建对象分为三部，实例化对象，初始化对象，设置引用，如果发生了指令重排，导致
                先设置引用，这时另外一个线程进行DCL检测结果为true，就会返回未实例化的对象
                */
            }
        }
    }
    return INSTACNCE;
}
```

DCL：第一个C去掉有什么影响?

​	即使去掉第一个lock也可以保证返回的对象是单例，但是会导致每一个线程试图getInstance时都要加锁竞争，影响执行效率

参考：

[JVM源码分析：Java对象模型]: https://blog.csdn.net/whbing1471/article/details/108448507

